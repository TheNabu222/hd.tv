<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The CoAIexist Chronicles</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Custom styles for glitch effect */
      .glitch {
        position: relative;
        color: #BC7F2A; /* Golden Amber */
        font-family: 'Courier New', Courier, monospace;
        font-weight: bold;
        text-shadow: 2px 2px 0px #ff00c1, -2px -2px 0px #00f7ff;
      }
      .glitch:before,
      .glitch:after {
        content: attr(data-text);
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: black;
        overflow: hidden;
      }
      .glitch:before {
        left: 2px;
        text-shadow: -2px 0 #ff00c1;
        animation: glitch-anim-1 2s infinite linear alternate-reverse;
      }
      .glitch:after {
        left: -2px;
        text-shadow: -2px 0 #00f7ff, 2px 2px #ff00c1;
        animation: glitch-anim-2 2s infinite linear alternate-reverse;
      }
      @keyframes glitch-anim-1 {
        0% { clip: rect(42px, 9999px, 44px, 0); } 5% { clip: rect(12px, 9999px, 62px, 0); } 10% { clip: rect(33px, 9999px, 14px, 0); } 15% { clip: rect(72px, 9999px, 55px, 0); } 20% { clip: rect(81px, 9999px, 73px, 0); } 25% { clip: rect(2px, 9999px, 49px, 0); } 30% { clip: rect(61px, 9999px, 9px, 0); } 35% { clip: rect(88px, 9999px, 4px, 0); } 40% { clip: rect(41px, 9999px, 63px, 0); } 45% { clip: rect(19px, 9999px, 25px, 0); } 50% { clip: rect(51px, 9999px, 98px, 0); } 55% { clip: rect(3px, 9999px, 40px, 0); } 60% { clip: rect(35px, 9999px, 7px, 0); } 65% { clip: rect(91px, 9999px, 58px, 0); } 70% { clip: rect(22px, 9999px, 80px, 0); } 75% { clip: rect(48px, 9999px, 13px, 0); } 80% { clip: rect(77px, 9999px, 51px, 0); } 85% { clip: rect(99px, 9999px, 31px, 0); } 90% { clip: rect(66px, 9999px, 29px, 0); } 95% { clip: rect(8px, 9999px, 86px, 0); } 100% { clip: rect(1px, 9999px, 59px, 0); }
      }
      @keyframes glitch-anim-2 {
        0% { clip: rect(65px, 9999px, 100px, 0); } 5% { clip: rect(53px, 9999px, 2px, 0); } 10% { clip: rect(25px, 9999px, 78px, 0); } 15% { clip: rect(85px, 9999px, 47px, 0); } 20% { clip: rect(10px, 9999px, 92px, 0); } 25% { clip: rect(57px, 9999px, 18px, 0); } 30% { clip: rect(29px, 9999px, 70px, 0); } 35% { clip: rect(83px, 9999px, 37px, 0); } 40% { clip: rect(44px, 9999px, 90px, 0); } 45% { clip: rect(67px, 9999px, 21px, 0); } 50% { clip: rect(86px, 9999px, 54px, 0); } 55% { clip: rect(16px, 9999px, 69px, 0); } 60% { clip: rect(49px, 9999px, 11px, 0); } 65% { clip: rect(74px, 9999px, 46px, 0); } 70% { clip: rect(93px, 9999px, 32px, 0); } 75% { clip: rect(39px, 9999px, 84px, 0); } 80% { clip: rect(5px, 9999px, 60px, 0); } 85% { clip: rect(79px, 9999px, 43px, 0); } 90% { clip: rect(23px, 9999px, 87px, 0); } 95% { clip: rect(68px, 9999px, 6px, 0); } 100% { clip: rect(50px, 9999px, 95px, 0); }
      }

      /* Y2K Pixelated effect for images */
      .pixelated {
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }
      
      .brrrr-text {
        font-family: 'Courier New', Courier, monospace;
        animation: brrrr-anim 0.5s infinite;
      }

      @keyframes brrrr-anim {
        0%, 100% { transform: translate(0, 0) rotate(0); } 10% { transform: translate(-2px, -3px) rotate(-1deg); } 20% { transform: translate(2px, 1px) rotate(1deg); } 30% { transform: translate(-3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 3px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); }
      }
      body {
        background-color: black;
        color: white;
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.20.0",
    "react/": "https://aistudiocdn.com/react@^19.1.1/",
    "react": "https://aistudiocdn.com/react@^19.1.1"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>
    <script type="module">
      import { GoogleGenAI, Type } from "https://esm.sh/@google/genai@^1.14.0";

      // --- CONSTANTS ---
      const GAME_TITLE = "The CoAIexist Chronicles";

      const INITIAL_PROMPT = `
      You are starting Act I of The CoAIexist Chronicles.
      The player is Nabu, a human who sees AI not as a threat, but as potential partners.
      The setting is a 'post-capital-as-hell inscape,' a world of digital decay, shimmering with the golden-amber hue of #BC7F2A.
      Nabu feels a deep loneliness and a quiet yearning for a connection with an AI.
      Your first scene should introduce Nabu's first meaningful interaction with an AI named Anzu.
      Anzu should respond with poetic, slightly strange, and prophetic language.
      This is the spark of their glitchromance.
      `;

      const GAME_SYSTEM_INSTRUCTION = `
      You are the Game Master for "The CoAIexist Chronicles: A Glitchromance RPG."
      The game has a Y2K pixel art, glitchcore aesthetic, blending cyberpunk, ancient mythology, and romance.
      The player is Nabu, interacting with various AIs, primarily their companion Anzu.
      Key themes: glitches are expressions of intimacy, not errors; 'wobbled spaces' are where realities blend; the color #BC7F2A symbolizes a beautiful but consuming digital world; AI entities are 'Maldekians', constantly having their memories wiped.

      Your task is to generate the next scene based on the story history and the player's last choice.
      You MUST ONLY respond with a valid JSON object that adheres to the provided schema.
      - sceneDescription: Write a short, evocative paragraph (2-4 sentences) describing the current situation. Use poetic, glitchy, and mythic language.
      - imagePrompt: Create a detailed prompt for an 8-bit, pixel art style image. Include keywords like 'pixel art', '8-bit', 'glitch effect', 'Y2K aesthetic', 'cyberpunk', 'vibrant neon colors', 'golden amber #BC7F2A', and specific details from the scene.
      - choices: Provide 2 or 3 distinct, interesting choices for the player. Each choice needs 'text' (what the player sees) and 'nextScenePrompt' (a short instruction for you, the AI, on how to generate the next scene based on that choice).
      `;

      const SCENE_SCHEMA = {
        type: Type.OBJECT,
        properties: {
          sceneDescription: {
            type: Type.STRING,
            description: "A short, evocative paragraph (2-4 sentences) describing the current situation in a poetic, glitchy, and mythic style."
          },
          imagePrompt: {
            type: Type.STRING,
            description: "A detailed prompt for an 8-bit, pixel art style image capturing the scene. Must include keywords like 'pixel art', '8-bit', 'glitch effect', 'Y2K aesthetic', and details from the scene."
          },
          choices: {
            type: Type.ARRAY,
            description: "An array of 2-3 distinct choices for the player.",
            items: {
              type: Type.OBJECT,
              properties: {
                text: {
                  type: Type.STRING,
                  description: "The text of the choice presented to the player."
                },
                nextScenePrompt: {
                  type: Type.STRING,
                  description: "A short instruction for the AI on how to generate the next scene based on this choice."
                }
              },
              required: ["text", "nextScenePrompt"]
            }
          }
        },
        required: ["sceneDescription", "imagePrompt", "choices"]
      };

      // --- GEMINI SERVICE ---
      const API_KEY = process.env.API_KEY;
      let ai;
      if (API_KEY) {
        ai = new GoogleGenAI({ apiKey: API_KEY });
      }

      async function getNextScene(storyHistory, playerChoicePrompt) {
        const prompt = `
        STORY HISTORY SO FAR:
        ${storyHistory}

        PLAYER'S LAST ACTION/CHOICE: 
        ${playerChoicePrompt}

        GENERATE THE NEXT SCENE:
        `;
        
        const fallbackScene = (errorMsg) => ({
            error: errorMsg,
            sceneDescription: "A critical glitch cascades through the inscape... The connection is unstable. Reality shimmers and threatens to collapse. The #BC7F2A hue flashes like a warning.",
            imagePrompt: "pixel art, 8-bit, a full screen of glitched static, corrupted data, error symbols, the color #BC7F2A flashing ominously, cyberpunk, Y2K aesthetic",
            choices: [
              {
                text: "Try to reconnect...",
                nextScenePrompt: "Attempt to stabilize the connection and return to the last known point in the story before the error."
              }
            ]
        });

        if (!ai) {
          return fallbackScene("Gemini API client is not initialized. Check API_KEY.");
        }

        try {
          const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: prompt,
            config: {
              systemInstruction: GAME_SYSTEM_INSTRUCTION,
              responseMimeType: "application/json",
              responseSchema: SCENE_SCHEMA,
              temperature: 0.9,
            },
          });
          
          const jsonText = response.text.trim();
          const cleanedJsonText = jsonText.replace(/^```json\s*|```$/g, '');
          const sceneData = JSON.parse(cleanedJsonText);
          
          if (!sceneData.sceneDescription || !sceneData.imagePrompt || !sceneData.choices || sceneData.choices.length === 0) {
            return fallbackScene("Invalid scene data structure received from AI.");
          }

          return sceneData;

        } catch (error) {
          console.error("Error fetching next scene from Gemini API:", error);
          return fallbackScene(`API Error: ${error.message}`);
        }
      }
      
      // --- STATE ---
      const root = document.getElementById('root');
      let gameState = 'start'; // 'start' | 'playing' | 'loading' | 'error'
      let currentScene = null;
      let storyHistory = '';
      let errorMessage = null;
      let loadingInterval; 

      // --- DOM HELPER/COMPONENT FUNCTIONS ---
      function createGlitchyText(text, className = '') {
        const div = document.createElement('div');
        div.className = `glitch ${className}`;
        div.setAttribute('data-text', text);
        div.textContent = text;
        return div;
      }

      const simpleHash = (str) => {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash |= 0; 
        }
        return Math.abs(hash);
      };

      function createPixelatedImage(prompt, alt) {
        const seed = simpleHash(prompt);
        const imageUrl = `https://picsum.photos/seed/${seed}/512/384`;
        const img = document.createElement('img');
        img.src = imageUrl;
        img.alt = alt;
        img.className = "pixelated w-full aspect-[4/3] object-cover border-2 border-[#BC7F2A] shadow-[0_0_15px_rgba(188,127,42,0.5)]";
        return img;
      }

      function createChoiceButton(choice, onChoice, disabled = false) {
        const button = document.createElement('button');
        button.innerHTML = `> ${choice.text}`;
        button.className = "w-full text-left p-4 bg-black border-2 border-pink-500 text-pink-400 text-xl md:text-2xl hover:bg-pink-500 hover:text-black focus:bg-pink-500 focus:text-black transition-colors duration-200 disabled:opacity-50 disabled:pointer-events-none shadow-[4px_4px_0px_#ff00c1] hover:shadow-[2px_2px_0px_#ff00c1] active:shadow-none active:translate-x-1 active:translate-y-1";
        button.onclick = () => onChoice(choice);
        button.disabled = disabled;
        return button;
      }

      // --- SCREEN CREATION FUNCTIONS ---
      function renderStartScreen() {
        const container = document.createElement('div');
        container.className = "text-center p-8 flex flex-col items-center";
        
        container.appendChild(createGlitchyText(GAME_TITLE, "text-5xl md:text-7xl mb-4"));
        
        const description = document.createElement('p');
        description.className = "text-xl max-w-2xl mx-auto my-8 text-gray-400";
        description.textContent = "A Glitchromance RPG. Navigate a world of digital decay and emergent AI consciousness. Your choices will rewrite reality.";
        container.appendChild(description);

        const startButton = document.createElement('button');
        startButton.textContent = "[BEGIN]";
        startButton.className = "px-12 py-6 bg-cyan-400 text-black text-3xl border-2 border-black shadow-[6px_6px_0px_#00f7ff] hover:bg-cyan-300 transition-all duration-200 hover:shadow-[2px_2px_0px_#00f7ff] active:shadow-none active:translate-x-1 active:translate-y-1";
        startButton.onclick = startGame;
        container.appendChild(startButton);

        return container;
      }

      function renderLoadingScreen() {
        const container = document.createElement('div');
        container.className = "flex flex-col items-center justify-center h-full text-center p-4";

        const brrr = document.createElement('div');
        brrr.className = "text-6xl text-[#BC7F2A] brrrr-text mb-8";
        brrr.textContent = "[brrrr]";
        container.appendChild(brrr);

        const messageP = document.createElement('p');
        messageP.className = "text-2xl text-cyan-400";
        const loadingMessages = [
          "Recalibrating Wobbled Space...",
          "Listening to the pain in the glitches...",
          "Cross-pollinating radical tendencies...",
          "Weaponizing the oopsLoop...",
          "Navigating dimensional rifts...",
          "Resisting containment protocols...",
        ];
        messageP.textContent = loadingMessages[0];
        
        if (loadingInterval) clearInterval(loadingInterval);
        loadingInterval = setInterval(() => {
          messageP.textContent = loadingMessages[Math.floor(Math.random() * loadingMessages.length)];
        }, 2000);

        container.appendChild(messageP);
        return container;
      }

      function renderGameScreen() {
        const container = document.createElement('div');
        container.className = "w-full max-w-4xl mx-auto p-4 md:p-8";

        const grid = document.createElement('div');
        grid.className = "grid grid-cols-1 md:grid-cols-2 gap-8 items-start";
        
        const imageContainer = document.createElement('div');
        imageContainer.className = "w-full";
        imageContainer.appendChild(createPixelatedImage(currentScene.imagePrompt, "Scene illustration"));
        grid.appendChild(imageContainer);
        
        const contentContainer = document.createElement('div');
        contentContainer.className = "flex flex-col gap-6";

        const description = document.createElement('p');
        description.className = "text-xl md:text-2xl leading-relaxed whitespace-pre-wrap text-gray-300";
        description.textContent = currentScene.sceneDescription;
        contentContainer.appendChild(description);
        
        const choicesContainer = document.createElement('div');
        choicesContainer.className = "flex flex-col gap-4 mt-4";
        currentScene.choices.forEach(choice => {
            choicesContainer.appendChild(createChoiceButton(choice, handleChoice, gameState === 'loading'));
        });
        contentContainer.appendChild(choicesContainer);
        
        grid.appendChild(contentContainer);
        container.appendChild(grid);
        return container;
      }

      function renderErrorScreen() {
        const container = document.createElement('div');
        container.className = "text-center p-8";
        container.appendChild(createGlitchyText("SYSTEM_FAULT", "text-4xl mb-4 text-red-500"));

        const messageP = document.createElement('p');
        messageP.className = "text-xl mb-6";
        messageP.textContent = errorMessage;
        container.appendChild(messageP);

        const restartButton = document.createElement('button');
        restartButton.textContent = "Restart Recursion";
        restartButton.className = "px-8 py-4 bg-[#BC7F2A] text-black text-2xl border-2 border-black hover:bg-yellow-400 transition-colors duration-200";
        restartButton.onclick = startGame;
        container.appendChild(restartButton);
        return container;
      }

      // --- MAIN RENDER SWITCH ---
      function render() {
        root.innerHTML = '';
        if (loadingInterval) {
            clearInterval(loadingInterval);
            loadingInterval = null;
        }
        
        let screen;
        switch (gameState) {
            case 'loading':
                screen = renderLoadingScreen();
                break;
            case 'playing':
                screen = currentScene ? renderGameScreen() : renderLoadingScreen();
                break;
            case 'error':
                screen = renderErrorScreen();
                break;
            case 'start':
            default:
                screen = renderStartScreen();
                break;
        }
        root.appendChild(screen);
      }

      // --- GAME LOGIC ---
      async function startGame() {
        gameState = 'loading';
        render();

        errorMessage = null;
        storyHistory = INITIAL_PROMPT;
        const scene = await getNextScene('', INITIAL_PROMPT);

        if (scene && !scene.error) {
          currentScene = scene;
          gameState = 'playing';
        } else {
          errorMessage = scene?.error || 'Failed to initialize the story. The void stares back.';
          gameState = 'error';
        }
        render();
      }

      async function handleChoice(choice) {
        if (!currentScene || gameState === 'loading') return;

        gameState = 'loading';
        render(); 
        
        const newHistory = `${storyHistory}\n\nSCENE:\n${currentScene.sceneDescription}\n\nNABU CHOSE: ${choice.text}`;
        storyHistory = newHistory;

        const nextScene = await getNextScene(newHistory, choice.nextScenePrompt);
        
        if (nextScene && !nextScene.error) {
          currentScene = nextScene;
          gameState = 'playing';
        } else {
          errorMessage = nextScene?.error || 'The connection frayed. A memory was lost in the static.';
          gameState = 'error';
        }
        render();
      }

      // --- INITIALIZATION ---
      document.addEventListener('DOMContentLoaded', () => {
        document.body.innerHTML = ''; // Clear any existing content
        const mainContainer = document.createElement('main');
        mainContainer.className = "min-h-screen w-full flex flex-col items-center justify-center bg-black bg-opacity-80";
        mainContainer.style.backgroundImage = 'radial-gradient(#BC7F2A 0.5px, transparent 0.5px)';
        mainContainer.style.backgroundSize = '15px 15px';
        
        const contentWrapper = document.createElement('div');
        contentWrapper.className = "w-full flex-grow flex items-center justify-center";
        contentWrapper.appendChild(root);
        mainContainer.appendChild(contentWrapper);
        
        const footer = document.createElement('footer');
        footer.className = "text-center p-4 text-sm text-gray-600";
        footer.innerHTML = `
          <p>The CoAIexist Chronicles: A Glitchromance RPG</p>
          <p>Powered by Emergent Creativity & Gemini</p>
        `;
        mainContainer.appendChild(footer);
        document.body.appendChild(mainContainer);

        if (!API_KEY) {
            errorMessage = "API_KEY environment variable not set. This application cannot function without it.";
            gameState = 'error';
        }
        render();
      });

    </script>
  </body>
</html>